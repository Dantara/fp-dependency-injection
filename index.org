#+TITLE: Dependency injection
#+SUBTITLE: in functional programming
#+AUTHOR: Nikita Aleshchenko

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_THEME: styles/tinkoff.css
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_HIGHLIGHT_CSS: styles/monokai.css
#+REVEAL_EXTRA_CSS: styles/extra.css
#+REVEAL_EXTRA_CSS: https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css
#+OPTIONS: num:nil toc:nil reveal_width:1075
#+REVEAL_TRANS: slide
#+REVEAL_MARGIN: 0
# #+REVEAL_EXTERNAL_PLUGINS: (Animate . "./plugins/animate.js")

#+REVEAL_TITLE_SLIDE: <img src="images/logo.svg" id="title-img">
#+REVEAL_TITLE_SLIDE: <h2 class="title">%t</h2>
#+REVEAL_TITLE_SLIDE: <h3 class="subtitle">%s</h3>
#+REVEAL_TITLE_SLIDE: <h6 class="author">%a</h6>
#+REVEAL_TITLE_SLIDE_BACKGROUND: rgb(255, 221, 45)
#+REVEAL_TITLE_SLIDE_STATE: title-slide

#+INCLUDE: ./about.html export html

* –ú—ã –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ö–æ—Ç–∏–º –ø–∏—Å–∞—Ç—å...
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
* –ú—ã –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ö–æ—Ç–∏–º –ø–∏—Å–∞—Ç—å...
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :frag appear
+ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –†–∞—Å—à–∏—Ä—è–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –¢–µ—Å—Ç–∏—Ä—É–µ–º—ã–π –∫–æ–¥;

* Dependency injection
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
* Dependency injection
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
# Dependency Injection (–í–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π) is a software design technique in which the creation and binding of dependencies are done outside of the dependent class.
Dependency Injection (–í–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π) - —ç—Ç–æ –º–µ—Ç–æ–¥ –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º —Å–æ–∑–¥–∞–Ω–∏–µ –∏ –ø—Ä–∏–≤—è–∑–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤–Ω–µ –∑–∞–≤–∏—Å–∏–º–æ–≥–æ –∫–ª–∞—Å—Å–∞.

** –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ DI
#+ATTR_REVEAL: :frag appear
+ Separation of concerns (–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π);
  + –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –∫–æ–¥;
  + –†–∞—Å—à–∏—Ä—è–µ–º—ã–π –∫–æ–¥;
  + –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å;


* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle"></span>

* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle green-border"></span>

* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle red-border"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle"></span>


** –¢—Ä–µ—Ö —Å–ª–æ–π–Ω—ã–π –ø–∏—Ä–æ–≥
| ‚Ññ      | –°–ª–æ–π                  |
|--------+-----------------------|
|      3 | –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞         |
|      2 | DSL –¥–ª—è –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏ |
|      1 | –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä         |

* –¢–µ—Å—Ç–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç
** –ë–æ—Ç –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
–ü–æ–ª—É—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ long polling, –ø–µ—Ä–µ–≤–æ–¥–∏—Ç —Å –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ –Ω–∞ —Ä—É—Å—Å–∫–∏–π, –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.

+ –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π;
+ –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π;
+ –ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞;
** Gist
#+ATTR_REVEAL: :code_attribs data-line-numbers='1-23|1-4|6-7|9-10|12-13|15|16|17|19|20|21-32'
#+BEGIN_SRC haskell
data Message = Msg
  { chatId :: Integer
  , text   :: Text
  }

pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: Message -> IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...

proceed :: IO ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: Message -> IO Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ü—Ä–æ–±–ª–µ–º—ã
+ –í–µ—Å—å –∫–æ–¥ –≤ IO; üöÄ
+ –ù–µ —Ç–µ—Å—Ç–∏—Ä—É–µ–º—ã–π –∫–æ–¥;

* Handle / Service pattern
** –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ
+ –§—É–Ω–∫—Ü–∏–∏;
+ –î–∞–Ω–Ω—ã–µ;
** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
#+BEGIN_SRC haskell
data Handle = Handle
    { hPool   :: Pool Postgres.Connection
    , hCache  :: IORef (PSQueue Int Text User)
    , hLogger :: Logger.Handle  -- Another handle!
    , ...
    }
#+END_SRC
** Handle interface
#+BEGIN_SRC haskell
data Handle = Handle
    { createUser :: Text -> IO User
    , ...
    }
#+END_SRC

#+BEGIN_SRC haskell
createUser :: Handle -> Text -> IO User
createUser = ...
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers='1-18|1-8'
#+BEGIN_SRC haskell
pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...

proceed :: IO ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: Message -> IO Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers
#+BEGIN_SRC haskell
pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: Message -> IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: Message -> IO ()
  , translate   :: Text -> IO (Maybe Text)
  }
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers='1-5|1-16|7-16'
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: Message -> IO ()
  , translate   :: Text -> IO (Maybe Text)
  }

proceed :: Handle -> IO ()
proceed h = pullUpdates h
  >>= traverse_ (translateMsg >=> sendMessage h)
  where
    translateMsg :: Message -> m Message
    translateMsg (Msg ci t) = translate h t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))

#+END_SRC

** –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑—É–µ–º –º–æ–Ω–∞–¥—É
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: Message -> IO ()
  , translate   :: Text -> IO (Maybe Text)
  }
#+END_SRC

** –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑—É–µ–º –º–æ–Ω–∞–¥—É
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: Message -> m ()
  , translate   :: Text -> m (Maybe Text)
  }
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers='1-16|7'
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: Message -> m ()
  , translate   :: Text -> m (Maybe Text)
  }

proceed :: MonadIO m => Handle m -> m ()
proceed h = pullUpdates h
  >>= traverse_ (translateMsg >=> sendMessage h)
  where
    translateMsg :: Message -> m Message
    translateMsg (Msg ci t) = translate h t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))

#+END_SRC

** –ü–ª—é—Å—ã & –º–∏–Ω—É—Å—ã
** –ü–ª—é—Å—ã:
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ü–ª—é—Å—ã:
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :frag appear
  + –ü—Ä–æ—Å—Ç–æ & –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ;
#+ATTR_REVEAL: :frag appear
  + –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ;
#+ATTR_REVEAL: :frag appear
  + –ü–æ–¥–º–µ–Ω–∞ —Ö—ç–Ω–¥–ª–µ—Ä–æ–≤ –≤ —Ä–∞–Ω—Ç–∞–π–º–µ;

** –ú–∏–Ω—É—Å—ã:
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ú–∏–Ω—É—Å—ã:
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
  + –†—É—á–Ω–æ–µ –ø—Ä–æ–∫–∏–¥—ã–≤–∞–Ω–∏–µ —Ö—ç–Ω–¥–ª–µ—Ä–æ–≤;
  + –ü—Ä–∏–≤—è–∑–∞–Ω–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª–Ω—è—é—â–µ–π –º–æ–Ω–∞–¥–µ;

* Tagless final
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
* Tagless final
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
–ü–µ—Ä–µ—Ö–æ–¥ –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—ã *Handle* –∫ *Type class*'–∞–º!

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: Message -> m ()
  , translate   :: Text -> m (Maybe Text)
  }
#+END_SRC

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: Message -> m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

–ü–µ—Ä–µ—Ö–æ–¥ –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—ã *Handle* –∫ *Type class*'–∞–º!
#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-6|1-3|5-6'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: Message -> m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** Type families
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-7|2'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  type Message m :: *
  pullUpdates :: m [Message]
  sendMessage :: Message -> m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-16|8'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: Message -> m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)

proceed :: (MonadMessenger m, MonadTranslator m) => m ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: (MonadTranslator m) => Message -> m Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-2|2'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-9|4-9'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM where
  translate = ...
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-15|11-15|11|12|13|15|1,15|14'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM where
  translate = ...

interpret :: AppM a -> IO a
interpret app = do
  ctx <- retrieveContext
  flip runReaderT ctx
    $ runAppM app
#+END_SRC

** –ü–ª—é—Å—ã & –ú–∏–Ω—É—Å—ã
** –ü–ª—é—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ü–ª—é—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :frag appear
+ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å;
#+ATTR_REVEAL: :frag appear
+ "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è" –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏;
#+ATTR_REVEAL: :frag appear
+ –ê–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ –º–µ–Ω—å—à–µ –ø—Ä–æ—Ç–µ–∫–∞—é—Ç;
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ß–∞—Å—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π –ø—Ä–æ—Ç–µ–∫–∞e—Ç:
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ß–∞—Å—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π –ø—Ä–æ—Ç–µ–∫–∞e—Ç:
#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim
#+BEGIN_SRC haskell
class MonadTranslator m
#+END_SRC
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ß–∞—Å—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π –ø—Ä–æ—Ç–µ–∫–∞e—Ç:
#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim
#+BEGIN_SRC haskell
class MonadDB m => MonadTranslator m
#+END_SRC
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ –Ω–∏–∂–µ –ø–æ —Å—Ç—ç–∫—É:
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ –Ω–∏–∂–µ –ø–æ —Å—Ç—ç–∫—É:
#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-9|11-16|13'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM where
  translate = ...

instance MonadMessenger m => MonadMessenger (ReaderT r m) where
  pullUpdates     = ReaderT $ \_ -> pullUpdates
  sendMessage msg = ReaderT $ \_ -> sendMessage msg

instance MonadTranslator m => MonadTranslator (ReaderT r m) where
  translate t = ReaderT $ \_ -> translate t
#+END_SRC
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ "—Ä–µ–∏–Ω—Ç—Ä–µ–ø—Ä–µ—Ç–∞—Ü–∏–∏" —ç—Ñ—Ñ–µ–∫—Ç–∞:
#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-9|11-19'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM where
  translate = ...

newtype AppM2 a = AppM2 { runAppM2 :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM2 where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM2 where
  translate = ...
#+END_SRC


* Free monads
** –ò–Ω—Ç–µ—Ä–ø—Ä–∏—Ç–∏—Ä—É–µ–º—ã–µ —è–∑—ã–∫–∏
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ò–Ω—Ç–µ—Ä–ø—Ä–∏—Ç–∏—Ä—É–µ–º—ã–µ —è–∑—ã–∫–∏
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

# #+ATTR_HTML: :width 40% :height 40% :style position: absolute left: 10vw;
# [[./images/ruby.png]]

#+ATTR_REVEAL: :frag appear
+ –ö–æ–¥;
#+ATTR_REVEAL: :frag appear
+ AST (Abtract syntax tree);
#+ATTR_REVEAL: :frag appear
+ –ò–Ω—Ç—Ä–µ–ø—Ä–µ—Ç–∞—Ç–æ—Ä;

** –ë–æ–ª—å—à–∞—è —Ç—Ä–æ–∏—Ü–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

*Functor*
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

*Applicative*
#+BEGIN_SRC haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
#+END_SRC

*Monad*
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** Functor
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** Applicative
#+BEGIN_SRC haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
#+END_SRC

** Monad
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** Monad
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

#+BEGIN_SRC haskell
join :: (Monad m) => m (m a) -> m a
#+END_SRC

** Monad
#+BEGIN_SRC haskell
join :: (Monad m) => m (m a) -> m a
fmap :: (a -> b) -> f a -> f b
#+END_SRC

#+BEGIN_SRC haskell
(>>=) :: m a -> (a -> m b) -> m b
(>>=) m f = join (fmap f m)
#+END_SRC

** Key Idea
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC

** Key Idea
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC

#+BEGIN_SRC haskell
Pure :: a -> m a        -- looks like pure
Free :: f (m a) -> m a  -- looks like join
#+END_SRC

** Functor instance
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC

#+BEGIN_SRC haskell
instance Functor f => Functor (Free f) where
  fmap g (Free fx) = Free (fmap g <$> fx)
  fmap g (Pure x)  = Pure (g x)
#+END_SRC

** Monad instance
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC

#+BEGIN_SRC haskell
instance Functor f => Monad (Free f) where
  return = Pure
  Pure x  >>= g  =  g x
  Free fx >>= g  =  Free ((>>= g) <$> fx)
#+END_SRC

** Business logic functor
#+BEGIN_SRC haskell
data BotF
  = PullUpdates [Message]
  | SendMessage Message
  | Translate Text (Maybe Text)
#+END_SRC

** Business logic functor
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates [Message] a
  | SendMessage Message a
  | Translate Text (Maybe Text) a
#+END_SRC

** Business logic functor
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)
#+END_SRC

** Business logic functor
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)
  deriving (Functor)

type Bot = Free BotF
#+END_SRC

** Lift functor
#+BEGIN_SRC haskell
liftF :: Functor f => f a -> Free f a
liftF command = Free (fmap Pure command)
#+END_SRC

** Helper functions
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)
#+END_SRC

#+BEGIN_SRC haskell
pullUpdates :: Bot [Message]
pullUpdates = liftF (PullUpdates id)

sendMessage :: Message -> Bot ()
sendMessage msg = liftF (SendMessage msg ())

translate :: Text -> Bot (Maybe Text)
translate t = liftF (Translate t id)
#+END_SRC

** Business logic
#+BEGIN_SRC haskell
proceed :: Bot ()
proceed h = pullUpdates
  >>= traverse_ (translateMsg >>= sendMessage)
  where
    translateMsg :: Message -> Bot Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** Interpreter
#+BEGIN_SRC haskell
botIO :: BotF a -> IO a
botIO (PullUpdates u) = ...
botIO (SendMessage m a) = ...
botIO (Translate t ft) = ...
#+END_SRC

** Interpreter helpers
#+BEGIN_SRC haskell
freeM :: (Functor f, Functor g)
      => (f a -> g a) -> Free f a -> Free g a
freeM phi (Pure x) = Pure x
freeM phi (Free fx) = Free $ phi (freeM phi <$> fx)
#+END_SRC

#+BEGIN_SRC haskell
monad :: Monad m => Free m a -> m a
monad (Pure x) = pure x
monad (Free mfx) = do
  fx <- mfx
  monad fx
#+END_SRC

#+BEGIN_SRC haskell
interp :: (Functor f, Monad m)
       => (f a -> m a) -> Free f a -> m a
interp phi = monad . freeM phi
#+END_SRC

** Interpreter
#+BEGIN_SRC haskell
botIO :: BotF a -> IO a
#+END_SRC

#+BEGIN_SRC haskell
interp :: (Functor f, Monad m)
       => (f a -> m a) -> Free f a -> m a
#+END_SRC

#+BEGIN_SRC haskell
interpBotIO :: Bot a -> IO a
interpBotIO = interp botIO
#+END_SRC

* Freer monads
** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a
  = First a
  | Second a
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: a -> SomeType a
  Second :: a -> SomeType a
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: a -> SomeType a
  Second :: Int -> SomeType Int
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: b -> SomeType b
  Second :: Int -> SomeType Int
#+END_SRC

** Free monad
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC
** Free monad
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Free f a where
  Pure   :: a -> Free f a
  Impure :: f (Free f a) -> Free f a
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Lan g a where
  Lan :: g x -> (x -> a) -> Lan g a

instance Functor (Lan g) where
  fmap f (Lan gx h) = Lan gx (f . h)

lan :: g a -> Lan g a
lan ga = Lan ga id
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Lan g b where
  Lan :: (a -> b) -> g a -> Lan g b

class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers data-trim data-line-numbers='1-14|1-5|8-14'
#+BEGIN_SRC haskell
data Lan g b where
  Lan :: (a -> b) -> g a -> Lan g b

class Functor f where
  fmap :: (a -> b) -> f a -> f b


data FFree g a where
  FPure   :: a -> FFree g a
  FImpure :: g x -> (x -> FFree g a) -> FFree g a

class Monad m where
  pure  :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
FFree g = Free (Lan f)
#+END_SRC

#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Lan g b where
  Lan :: (a -> b) -> g a -> Lan g b

class Functor f where
  fmap :: (a -> b) -> f a -> f b


data FFree g a where
  FPure   :: a -> FFree g a
  FImpure :: g x -> (x -> FFree g a) -> FFree g a

class Monad m where
  pure  :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
lan :: g a -> Lan g a
lan ga = Lan ga id

etaF :: g a -> FFree g a
etaF fa = FImpure fa FPure
#+END_SRC

** –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Bot f a where
  PullUpdates :: Bot [Message]
  SendMessage :: Message -> Bot ()
  Translate   :: Text -> Bot (Maybe Text)

type BotM f = FFree (Bot f)
#+END_SRC

* Effects systems
* Questions?

* Appendix

* Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
 *Type class* ‚âà *Interface*

** Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
 *Type class* ‚âà *Interface*

#+ATTR_REVEAL: :data_id type-class :code_attribs data-trim data-line-numbers='1-3|1|2|3'
#+BEGIN_SRC haskell
data Bool
  = True
  | False
#+END_SRC

** Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
 *Type class* ‚âà *Interface*

#+ATTR_REVEAL: :data_id type-class :code_attribs data-trim data-line-numbers='1-6|5-6|5|6'
#+BEGIN_SRC haskell
data Bool
  = True
  | False

class Show a where
  show :: a -> String
#+END_SRC

** Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
 *Type class* ‚âà *Interface*

#+ATTR_REVEAL: :data_id type-class :code_attribs data-trim data-line-numbers='1-10|8-10|8|9-10'
#+BEGIN_SRC haskell
data Bool
  = True
  | False

class Show a where
  show :: a -> String

instance Show Bool where
  show True  = "True"
  show False = "False"
#+END_SRC

** –§—É–Ω–∫—Ü–∏–∏ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
#+ATTR_REVEAL: :data_id tf
#+BEGIN_SRC haskell
map :: (a -> b) -> [a] -> [b]
#+END_SRC

** –¢–∏–ø—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id type-class2 :code_attribs
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** –¢–∏–ø—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id type-class2 :code_attribs data-line-numbers='1-2|1'
#+BEGIN_SRC haskell
class Functor (f :: Type -> Type) where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** –¢–∏–ø—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :data_id type-class2 :code_attribs data-line-numbers='1-6|4-6'
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b

instance Functor Maybe where
  fmap f (Just a) = Just $ f a
  fmap _ Nothing  = Nothing
#+END_SRC
