#+TITLE: Dependency injection
#+SUBTITLE: in functional programming
#+AUTHOR: Nikita Aleshchenko

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_THEME: styles/tinkoff.css
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_HIGHLIGHT_CSS: styles/monokai.css
#+REVEAL_EXTRA_CSS: styles/extra.css
#+REVEAL_EXTRA_CSS: https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css
#+OPTIONS: num:nil toc:nil reveal_width:1075
#+REVEAL_TRANS: slide
#+REVEAL_MARGIN: 0
# #+REVEAL_EXTERNAL_PLUGINS: (RevealAnimate . "plugins/animate.js")

#+REVEAL_TITLE_SLIDE: <img src="images/logo.svg" id="title-img">
#+REVEAL_TITLE_SLIDE: <h2 class="title">%t</h2>
#+REVEAL_TITLE_SLIDE: <h3 class="subtitle">%s</h3>
#+REVEAL_TITLE_SLIDE: <h6 class="author">%a</h6>
#+REVEAL_TITLE_SLIDE_BACKGROUND: rgb(255, 221, 45)
#+REVEAL_TITLE_SLIDE_STATE: title-slide

#+INCLUDE: ./about.html export html

* –ú—ã –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ö–æ—Ç–∏–º –ø–∏—Å–∞—Ç—å...
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
* –ú—ã –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ö–æ—Ç–∏–º –ø–∏—Å–∞—Ç—å...
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :frag appear
+ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –†–∞—Å—à–∏—Ä—è–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –¢–µ—Å—Ç–∏—Ä—É–µ–º—ã–π –∫–æ–¥;

* Dependency injection
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
* Dependency injection
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
# Dependency Injection (–í–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π) is a software design technique in which the creation and binding of dependencies are done outside of the dependent class.
Dependency Injection (–í–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π) - —ç—Ç–æ –º–µ—Ç–æ–¥ –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º —Å–æ–∑–¥–∞–Ω–∏–µ –∏ –ø—Ä–∏–≤—è–∑–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤–Ω–µ –∑–∞–≤–∏—Å–∏–º–æ–≥–æ –∫–ª–∞—Å—Å–∞.

** –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ DI
#+ATTR_REVEAL: :frag appear
+ Separation of concerns (–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π);
  + –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –∫–æ–¥;
  + –†–∞—Å—à–∏—Ä—è–µ–º—ã–π –∫–æ–¥;
  + –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å;


* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle"></span>

* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle green-border"></span>

* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle red-border"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle"></span>


** –¢—Ä–µ—Ö —Å–ª–æ–π–Ω—ã–π –ø–∏—Ä–æ–≥
| ‚Ññ      | –°–ª–æ–π                  |
|--------+-----------------------|
|      3 | –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞         |
|      2 | DSL –¥–ª—è –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏ |
|      1 | –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä         |

* –¢–µ—Å—Ç–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç
** –ë–æ—Ç –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
–ü–æ–ª—É—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ long polling, –ø–µ—Ä–µ–≤–æ–¥–∏—Ç —Å –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ –Ω–∞ —Ä—É—Å—Å–∫–∏–π, –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.

+ –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π;
+ –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π;
+ –ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞;
** Gist
#+ATTR_REVEAL: :code_attribs data-line-numbers='1-23|1-4|6-7|9-10|12-13|15|16|17|19|20|21-32'
#+BEGIN_SRC haskell
data Message = Msg
  { chatId :: Integer
  , text   :: Text
  }

pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...

proceed :: IO ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: Message -> IO Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ü—Ä–æ–±–ª–µ–º—ã
+ –í–µ—Å—å –∫–æ–¥ –≤ IO; üöÄ
+ –ù–µ —Ç–µ—Å—Ç–∏—Ä—É–µ–º—ã–π –∫–æ–¥;

* Handle / Service pattern
** –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ
+ –§—É–Ω–∫—Ü–∏–∏;
+ –î–∞–Ω–Ω—ã–µ;
** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
#+BEGIN_SRC haskell
data Handle = Handle
    { hPool   :: Pool Postgres.Connection
    , hCache  :: IORef (PSQueue Int Text User)
    , hLogger :: Logger.Handle  -- Another handle!
    , ...
    }
#+END_SRC
** Handle interface
#+BEGIN_SRC haskell
data Handle = Handle
    { createUser :: Text -> IO User
    , ...
    }
#+END_SRC

#+BEGIN_SRC haskell
createUser :: Handle -> Text -> IO User
createUser = ...
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers='1-18|1-8'
#+BEGIN_SRC haskell
pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...

proceed :: IO ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: Message -> IO Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers
#+BEGIN_SRC haskell
pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: IO ()
  , translate   :: Text -> IO (Maybe Text)
  }
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers='1-5|1-16|7-16'
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: IO ()
  , translate   :: Text -> IO (Maybe Text)
  }

proceed :: Handle -> IO ()
proceed h = pullUpdates h
  >>= traverse_ (translateMsg >=> sendMessage h)
  where
    translateMsg :: Message -> m Message
    translateMsg (Msg ci t) = translate h t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))

#+END_SRC

** –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑—É–µ–º –º–æ–Ω–∞–¥—É
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: IO ()
  , translate   :: Text -> IO (Maybe Text)
  }
#+END_SRC

** –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑—É–µ–º –º–æ–Ω–∞–¥—É
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: m ()
  , translate   :: Text -> m (Maybe Text)
  }
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers='1-16|7'
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: m ()
  , translate   :: Text -> m (Maybe Text)
  }

proceed :: MonadIO m => Handle m -> m ()
proceed h = pullUpdates h
  >>= traverse_ (translateMsg >=> sendMessage h)
  where
    translateMsg :: Message -> m Message
    translateMsg (Msg ci t) = translate h t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))

#+END_SRC

** –ü–ª—é—Å—ã –∏ –º–∏–Ω—É—Å—ã
*** –ü–ª—é—Å—ã:
  + –ü—Ä–æ—Å—Ç–æ & –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ;
  + –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ;
  + –ü–æ–¥–º–µ–Ω–∞ —Ö—ç–Ω–¥–ª–µ—Ä–æ–≤ –≤ —Ä–∞–Ω—Ç–∞–π–º–µ;

*** –ú–∏–Ω—É—Å—ã:
  + –†—É—á–Ω–æ–µ –ø—Ä–æ–∫–∏–¥—ã–≤–∞–Ω–∏–µ —Ö—ç–Ω–¥–ª–µ—Ä–æ–≤;
  + –ü—Ä–∏–≤—è–∑–∞–Ω–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª–Ω—è—é—â–µ–π –º–æ–Ω–∞–¥–µ;

* Tagless final
** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: m ()
  , translate   :: Text -> m (Maybe Text)
  }
#+END_SRC

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

–ü–µ—Ä–µ—Ö–æ–¥ –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—ã *Handle* –∫ *Type class*'–∞–º!
#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-6|1-3|5-6'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** Type families
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-7|2'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  type Message m :: *
  pullUpdates :: m [Message]
  sendMessage :: m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-16|8'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)

proceed :: (MonadMessenger m, MonadTranslator m) => m ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: (MonadTranslator m) => Message -> m Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –¢—É—Ç –±—É–¥–µ—Ç –µ—â—ë –ø–∞—á–∫–∞ —Å–ª–∞–π–¥–æ–≤

* Free monads
** –ò–Ω—Ç–µ—Ä–ø—Ä–∏—Ç–∏—Ä—É–µ–º—ã–µ —è–∑—ã–∫–∏
–¢—É—Ç –±—É–¥—É—Ç –∫–∞—Ä—Ç–∏–Ω–∫–∏

** –ë–æ–ª—å—à–∞—è —Ç—Ä–æ–∏—Ü–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

*Functor*
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

*Applicative*
#+BEGIN_SRC haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
#+END_SRC

*Monad*
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** Functor
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** Applicative
#+BEGIN_SRC haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
#+END_SRC

** Monad
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** Monad
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

#+BEGIN_SRC haskell
join :: (Monad m) => m (m a) -> m a
#+END_SRC

** Monad
#+BEGIN_SRC haskell
join :: (Monad m) => m (m a) -> m a
fmap :: (a -> b) -> f a -> f b
#+END_SRC

#+BEGIN_SRC haskell
(>>=) :: m a -> (a -> m b) -> m b
(>>=) m f = join (fmap f m)
#+END_SRC

** Key Idea
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC

** Key Idea
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC

#+BEGIN_SRC haskell
Pure :: a -> m a        -- looks like pure
Free :: f (m a) -> m a  -- looks like join
#+END_SRC

** Functor instance
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC

#+BEGIN_SRC haskell
instance Functor f => Functor (Free f) where
  fmap g (Free fx) = Free (fmap g <$> fx)
  fmap g (Pure x)  = Pure (g x)
#+END_SRC

** Monad instance
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC

#+BEGIN_SRC haskell
instance Functor f => Monad (Free f) where
  return = Pure
  Pure x  >>= g  =  g x
  Free fx >>= g  =  Free ((>>= g) <$> fx)
#+END_SRC

** Business logic functor
#+BEGIN_SRC haskell
data BotF
  = PullUpdates [Message]
  | SendMessage Message
  | Translate Text (Maybe Text)
#+END_SRC

** Business logic functor
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates [Message] a
  | SendMessage Message a
  | Translate Text (Maybe Text) a
#+END_SRC

** Business logic functor
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)
#+END_SRC

** Business logic functor
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)
  deriving (Functor)

type Bot = Free BotF
#+END_SRC

** Lift functor
#+BEGIN_SRC haskell
liftF :: Functor f => f a -> Free f a
liftF command = Free (fmap Pure command)
#+END_SRC


** Helper functions
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)
#+END_SRC

#+BEGIN_SRC haskell
pullUpdates :: Bot [Message]
pullUpdates = liftF (PullUpdates id)

sendMessage :: Message -> Bot ()
sendMessage msg = liftF (SendMessage msg ())

translate :: Text -> Bot (Maybe Text)
translate t = liftF (Translate t id)
#+END_SRC

** Business logic
#+BEGIN_SRC haskell
proceed :: Bot ()
proceed h = pullUpdates
  >>= traverse_ (translateMsg >>= sendMessage)
  where
    translateMsg :: Message -> Bot Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** Interpreter
#+BEGIN_SRC haskell
botIO :: BotF a -> IO a
botIO (PullUpdates u) = ...
botIO (SendMessage m a) = ...
botIO (Translate t ft) = ...
#+END_SRC

** Interpreter helpers
#+BEGIN_SRC haskell
freeM :: (Functor f, Functor g)
      => (f a -> g a) -> Free f a -> Free g a
freeM phi (Pure x) = Pure x
freeM phi (Free fx) = Free $ phi (freeM phi <$> fx)
#+END_SRC

#+BEGIN_SRC haskell
monad :: Monad m => Free m a -> m a
monad (Pure x) = pure x
monad (Free mfx) = do
  fx <- mfx
  monad fx
#+END_SRC

#+BEGIN_SRC haskell
interp :: (Functor f, Monad m)
       => (f a -> m a) -> Free f a -> m a
interp phi = monad . freeM phi
#+END_SRC

** Interpreter
#+BEGIN_SRC haskell
botIO :: BotF a -> IO a
#+END_SRC

#+BEGIN_SRC haskell
interp :: (Functor f, Monad m)
       => (f a -> m a) -> Free f a -> m a
#+END_SRC

#+BEGIN_SRC haskell
interpBotIO :: Bot a -> IO a
interpBotIO = interp botIO
#+END_SRC

* Freer monads
** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a
  = First a
  | Second a
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: a -> SomeType a
  Second :: a -> SomeType a
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: a -> SomeType a
  Second :: Int -> SomeType Int
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: b -> SomeType b
  Second :: Int -> SomeType Int
#+END_SRC

** Free monad
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
#+END_SRC
** Free monad
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Free f a where
  Pure   :: a -> Free f a
  Impure :: f (Free f a) -> Free f a
#+END_SRC
** Simple trick
#+BEGIN_SRC haskell
data Lan g a where
  Lan :: g x -> (x -> a) -> Lan g a

instance Functor (Lan g) where
  fmap f (Lan gx h) = Lan gx (f . h)

lan :: g a -> Lan g a
lan ga = Lan ga id
#+END_SRC
** Substitution
#+BEGIN_SRC haskell
data Free f a where
  Pure   :: a -> Free f a
  Impure :: f (Free f a) -> Free f a
#+END_SRC

#+ATTR_HTML: :width 5% :style margin: -15px;
[[./images/ArrowDown.png]]
#+BEGIN_SRC haskell
data Free (Lan g a) a where
  Pure   :: a -> Free (Lan g a) a
  Impure :: (Lan (Free (Lan g a) a) a) -> Free (Lan g a) a
#+END_SRC

#+ATTR_HTML: :width 5% :style margin: -15px;
[[./images/ArrowDown.png]]
#+BEGIN_SRC haskell
data FFree g a where
  FPure   :: a -> FFree g a
  FImpure :: g x -> (x -> FFree g a) -> FFree g a
#+END_SRC
* Effects systems
* Questions?
