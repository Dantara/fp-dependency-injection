#+TITLE: Dependency injection
#+SUBTITLE: in functional programming
#+AUTHOR: Nikita Aleshchenko

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_THEME: styles/tinkoff.css
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_HIGHLIGHT_CSS: styles/monokai.css
#+REVEAL_EXTRA_CSS: styles/extra.css
#+REVEAL_EXTRA_CSS: https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css
#+OPTIONS: num:nil toc:nil reveal_width:1075
#+REVEAL_TRANS: slide
#+REVEAL_MARGIN: 0
# #+REVEAL_EXTERNAL_PLUGINS: (Animate . "./plugins/animate.js")

#+REVEAL_TITLE_SLIDE: <img src="images/logo.svg" id="title-img">
#+REVEAL_TITLE_SLIDE: <h2 class="title">%t</h2>
#+REVEAL_TITLE_SLIDE: <h3 class="subtitle">%s</h3>
#+REVEAL_TITLE_SLIDE: <h6 class="author">%a</h6>
#+REVEAL_TITLE_SLIDE_BACKGROUND: rgb(255, 221, 45)
#+REVEAL_TITLE_SLIDE_STATE: title-slide

#+INCLUDE: ./about.html export html

* –ú—ã –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ö–æ—Ç–∏–º –ø–∏—Å–∞—Ç—å...
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
* –ú—ã –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ö–æ—Ç–∏–º –ø–∏—Å–∞—Ç—å...
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :frag appear
+ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –†–∞—Å—à–∏—Ä—è–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –¢–µ—Å—Ç–∏—Ä—É–µ–º—ã–π –∫–æ–¥;


* Dependency injection
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
* Dependency injection
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
# Dependency Injection (–í–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π) is a software design technique in which the creation and binding of dependencies are done outside of the dependent class.
Dependency Injection (–í–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π) - —ç—Ç–æ –º–µ—Ç–æ–¥ –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º —Å–æ–∑–¥–∞–Ω–∏–µ –∏ –ø—Ä–∏–≤—è–∑–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤–Ω–µ –∑–∞–≤–∏—Å–∏–º–æ–≥–æ –∫–ª–∞—Å—Å–∞.

** –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ DI
#+ATTR_REVEAL: :frag appear
+ Separation of concerns (–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π);
  + –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –∫–æ–¥;
  + –†–∞—Å—à–∏—Ä—è–µ–º—ã–π –∫–æ–¥;
  + –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫–æ–¥;
#+ATTR_REVEAL: :frag appear
+ –¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å;


* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle"></span>

* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle green-border"></span>

* Onion architecture
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+REVEAL_HTML: <span class="first-circle circle red-border"></span>
#+REVEAL_HTML: <span class="second-circle circle"></span>
#+REVEAL_HTML: <span class="third-circle circle"></span>


** –¢—Ä–µ—Ö —Å–ª–æ–π–Ω—ã–π –ø–∏—Ä–æ–≥
| ‚Ññ      | –°–ª–æ–π                  |
|--------+-----------------------|
|      3 | –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞         |
|      2 | DSL –¥–ª—è –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏ |
|      1 | –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä         |




* –¢–µ—Å—Ç–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç
** –ë–æ—Ç –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
–ü–æ–ª—É—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ long polling, –ø–µ—Ä–µ–≤–æ–¥–∏—Ç —Å –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ –Ω–∞ —Ä—É—Å—Å–∫–∏–π, –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.

+ –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π;
+ –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π;
+ –ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞;
** Gist
#+ATTR_REVEAL: :code_attribs data-line-numbers='1-23|1-4|6-7|9-10|12-13|15|16|17|19|20|21-32'
#+BEGIN_SRC haskell
data Message = Msg
  { chatId :: Integer
  , text   :: Text
  }

pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: Message -> IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...

proceed :: IO ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: Message -> IO Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ü—Ä–æ–±–ª–µ–º—ã
+ –í–µ—Å—å –∫–æ–¥ –≤ IO; üöÄ
+ –ù–µ —Ç–µ—Å—Ç–∏—Ä—É–µ–º—ã–π –∫–æ–¥;


* Handle / Service pattern
** –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ
+ –§—É–Ω–∫—Ü–∏–∏;
+ –î–∞–Ω–Ω—ã–µ;
** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
#+BEGIN_SRC haskell
data Handle = Handle
    { hPool   :: Pool Postgres.Connection
    , hCache  :: IORef (PSQueue Int Text User)
    , hLogger :: Logger.Handle  -- Another handle!
    , ...
    }
#+END_SRC
** Handle interface
#+BEGIN_SRC haskell
data Handle = Handle
    { createUser :: Text -> IO User
    , ...
    }
#+END_SRC

#+BEGIN_SRC haskell
createUser :: Handle -> Text -> IO User
createUser = ...
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers='1-18|1-8'
#+BEGIN_SRC haskell
pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...

proceed :: IO ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: Message -> IO Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers
#+BEGIN_SRC haskell
pullUpdates :: IO [Message]
pullUpdates = ...

sendMessage :: Message -> IO ()
sendMessage = ...

translate :: Text -> IO (Maybe Text)
translate = ...
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: Message -> IO ()
  , translate   :: Text -> IO (Maybe Text)
  }
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle :code_attribs data-line-numbers='1-5|1-16|7-16'
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: Message -> IO ()
  , translate   :: Text -> IO (Maybe Text)
  }

proceed :: Handle -> IO ()
proceed h = pullUpdates h
  >>= traverse_ (translateMsg >=> sendMessage h)
  where
    translateMsg :: Message -> m Message
    translateMsg (Msg ci t) = translate h t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))

#+END_SRC

** –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑—É–µ–º –º–æ–Ω–∞–¥—É
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle = Handle
  { pullUpdates :: IO [Message]
  , sendMessage :: Message -> IO ()
  , translate   :: Text -> IO (Maybe Text)
  }
#+END_SRC

** –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑—É–µ–º –º–æ–Ω–∞–¥—É
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: Message -> m ()
  , translate   :: Text -> m (Maybe Text)
  }
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :data_id handle2 :code_attribs data-line-numbers='1-16|7'
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: Message -> m ()
  , translate   :: Text -> m (Maybe Text)
  }

proceed :: MonadIO m => Handle m -> m ()
proceed h = pullUpdates h
  >>= traverse_ (translateMsg >=> sendMessage h)
  where
    translateMsg :: Message -> m Message
    translateMsg (Msg ci t) = translate h t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))

#+END_SRC

** –ü–ª—é—Å—ã & –º–∏–Ω—É—Å—ã
** –ü–ª—é—Å—ã:
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ü–ª—é—Å—ã:
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :frag appear
  + –ü—Ä–æ—Å—Ç–æ & –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ;
#+ATTR_REVEAL: :frag appear
  + –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ;
#+ATTR_REVEAL: :frag appear
  + –ü–æ–¥–º–µ–Ω–∞ —Ö—ç–Ω–¥–ª–µ—Ä–æ–≤ –≤ —Ä–∞–Ω—Ç–∞–π–º–µ;

** –ú–∏–Ω—É—Å—ã:
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ú–∏–Ω—É—Å—ã:
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
  + –†—É—á–Ω–æ–µ –ø—Ä–æ–∫–∏–¥—ã–≤–∞–Ω–∏–µ —Ö—ç–Ω–¥–ª–µ—Ä–æ–≤;
  + –ü—Ä–∏–≤—è–∑–∞–Ω–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª–Ω—è—é—â–µ–π –º–æ–Ω–∞–¥–µ;


* Tagless final
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
* Tagless final
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
–ü–µ—Ä–µ—Ö–æ–¥ –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—ã *Handle* –∫ *Type class*'–∞–º!

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Handle m = Handle
  { pullUpdates :: m [Message]
  , sendMessage :: Message -> m ()
  , translate   :: Text -> m (Maybe Text)
  }
#+END_SRC

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: Message -> m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

–ü–µ—Ä–µ—Ö–æ–¥ –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—ã *Handle* –∫ *Type class*'–∞–º!
#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-6|1-3|5-6'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: Message -> m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** Type families
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-7|2'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  type Message m :: *
  pullUpdates :: m [Message]
  sendMessage :: Message -> m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)
#+END_SRC

** –ù–∞—à –ø—Ä–æ–µ–∫—Ç
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf :code_attribs data-line-numbers='1-16|8'
#+BEGIN_SRC haskell
class Monad m => MonadMessenger m where
  pullUpdates :: m [Message]
  sendMessage :: Message -> m ()

class Monad m => MonadTranslator m where
  translate :: Text -> m (Maybe Text)

proceed :: (MonadMessenger m, MonadTranslator m) => m ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: (MonadTranslator m) => Message -> m Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-2|2'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-9|4-9'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM where
  translate = ...
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-15|11-15|11|12|13|15|1,15|14'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM where
  translate = ...

interpret :: AppM a -> IO a
interpret app = do
  ctx <- retrieveContext
  flip runReaderT ctx
    $ runAppM app
#+END_SRC

** –ü–ª—é—Å—ã & –ú–∏–Ω—É—Å—ã
** –ü–ª—é—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ü–ª—é—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :frag appear
+ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å;
#+ATTR_REVEAL: :frag appear
+ "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è" –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏;
#+ATTR_REVEAL: :frag appear
+ –ê–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ –º–µ–Ω—å—à–µ –ø—Ä–æ—Ç–µ–∫–∞—é—Ç;
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ß–∞—Å—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π –ø—Ä–æ—Ç–µ–∫–∞e—Ç:
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ß–∞—Å—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π –ø—Ä–æ—Ç–µ–∫–∞e—Ç:
#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim
#+BEGIN_SRC haskell
class MonadTranslator m
#+END_SRC
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ß–∞—Å—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π –ø—Ä–æ—Ç–µ–∫–∞e—Ç:
#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim
#+BEGIN_SRC haskell
class MonadDB m => MonadTranslator m
#+END_SRC
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ –Ω–∏–∂–µ –ø–æ —Å—Ç—ç–∫—É:
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ –Ω–∏–∂–µ –ø–æ —Å—Ç—ç–∫—É:
#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-9|11-16|13'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM where
  translate = ...

instance MonadMessenger m => MonadMessenger (ReaderT r m) where
  pullUpdates     = ReaderT $ \_ -> pullUpdates
  sendMessage msg = ReaderT $ \_ -> sendMessage msg

instance MonadTranslator m => MonadTranslator (ReaderT r m) where
  translate t = ReaderT $ \_ -> translate t
#+END_SRC
** –ú–∏–Ω—É—Å—ã
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
+ –ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ "—Ä–µ–∏–Ω—Ç—Ä–µ–ø—Ä–µ—Ç–∞—Ü–∏–∏" —ç—Ñ—Ñ–µ–∫—Ç–∞:
#+ATTR_REVEAL: :data_id tf-interpret :code_attribs data-trim data-line-numbers='1-9|11-19'
#+BEGIN_SRC haskell
newtype AppM a = AppM { runAppM :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM where
  translate = ...

newtype AppM2 a = AppM2 { runAppM2 :: ReaderT SomeContext IO a }
  deriving newtype (Functor, Applicative, Monad, ...)

instance MonadMessenger AppM2 where
  pullUpdates = ...
  sendMessage = ...

instance MonadTranslator AppM2 where
  translate = ...
#+END_SRC


* Free monads
** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º—ã–µ —è–∑—ã–∫–∏
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º—ã–µ —è–∑—ã–∫–∏
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

# #+ATTR_HTML: :width 40% :height 40% :style position: absolute left: 10vw;
# [[./images/ruby.png]]

#+ATTR_REVEAL: :frag appear
+ –ö–æ–¥;
#+ATTR_REVEAL: :frag appear
+ AST (Abtract syntax tree);
#+ATTR_REVEAL: :frag appear
+ –ò–Ω—Ç—Ä–µ–ø—Ä–µ—Ç–∞—Ç–æ—Ä;

** –ë–æ–ª—å—à–∞—è —Ç—Ä–æ–∏—Ü–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

*Functor*
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

*Applicative*
#+BEGIN_SRC haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
#+END_SRC

*Monad*
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** Functor
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** Applicative
#+BEGIN_SRC haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
#+END_SRC

** Monad
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** Monad
#+BEGIN_SRC haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

#+BEGIN_SRC haskell
join :: (Monad m) => m (m a) -> m a
#+END_SRC

** Monad
#+BEGIN_SRC haskell
join :: (Monad m) => m (m a) -> m a
fmap :: (a -> b) -> f a -> f b
#+END_SRC

#+BEGIN_SRC haskell
(>>=) :: m a -> (a -> m b) -> m b
(>>=) m f = join (fmap f m)
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data Bot
  = PullUpdates [Message]
  | SendMessage Message
  | Translate Text (Maybe Text)
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data Bot
  = PullUpdate Message
  | SendMessage Message
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data Bot next
  = PullUpdate Message next
  | SendMessage Message next
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data Bot a
  = PullUpdate Message (Bot a)
  | SendMessage Message (Bot a)
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data Bot a
  = PullUpdate (Message -> (Bot a))
  | SendMessage Message (Bot a)
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data Bot a
  = PullUpdate (Message -> (Bot a))
  | SendMessage Message (Bot a)
  | Done a
#+END_SRC

** –≠—Ö–æ –±–æ—Ç
#+BEGIN_SRC haskell
data Bot a
  = PullUpdate (Message -> (Bot a))
  | SendMessage Message (Bot a)
  | Done a

echo :: Bot ()
echo = PullUpdate $ \msg ->
       SendMessage msg
     $ Done ()
#+END_SRC

** Monad instance
#+BEGIN_SRC haskell
data Bot a
  = SendMessage Message (Bot a)
  | PullUpdate (Message -> (Bot a))
  | Done a

class Monad m where
  pure  :: m a
  (>>=) :: m a -> (a -> m b) -> m b

instance Monad Bot where
  pure = Done
  SendMessage msg k >>= f = SendMessage msg $ k >>= f
  PullUpdate      k >>= f = PullUpdate $ \msg -> k msg >>= f
#+END_SRC

** –≠—Ö–æ –±–æ—Ç
#+BEGIN_SRC haskell
data Bot a
  = PullUpdate (Message -> (Bot a))
  | SendMessage Message (Bot a)
  | Done a

echo :: Bot ()
echo = do
  msg <- PullUpdate Done
  SendMessage msg $ Done ()
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
#+BEGIN_SRC haskell
data Bot a
  = Done a
  | SendMessage Message (Bot a)
  | PullUpdate (Message -> (Bot a))

interpretBotIO :: Bot a -> IO a

interpretBotIO (Done a) = pure a

interpretBotIO (SendMessage msg m) = do
  sendMessageIO msg
  interpretBotIO m

interpretBotIO (PullUpdate f) = do
  msg <- pullMessageIO
  interpretBotIO $ f msg
#+END_SRC

** –ê–±—Å—Ç—Ä–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
#+BEGIN_SRC haskell
data Bot a
  = SendMessage Message (Bot a)
  | PullUpdate (Message -> (Bot a))
  | Done a
#+END_SRC

** –ê–±—Å—Ç—Ä–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
#+BEGIN_SRC haskell
data Bot a
  = SendMessage Message (Bot a)
  | PullUpdate (Message -> (Bot a))
  | Translate Text ((Maybe Text) -> Bot a)
  | Done a
#+END_SRC

** –ê–±—Å—Ç—Ä–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
#+BEGIN_SRC haskell
data BotF next
  = SendMessage Message next
  | PullUpdate (Message -> next)
  | Translate Text ((Maybe Text) -> next)

data Free f a
  = Pure a
  | Impure (f (Free f a))

type Bot a = Free BotF a
#+END_SRC

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Impure (f (Free f a))
#+END_SRC

** –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Impure (f (Free f a))

Pure   :: a -> Free f a             -- looks like pure
Impure :: f (Free f a) -> Free f a  -- looks like join

pure :: Monad m => a -> m a
join :: Monad m => m (m a) -> m a
#+END_SRC

** Functor instance
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Impure (f (Free f a))

instance Functor f => Functor (Free f) where
  fmap g (Pure x)    = Pure (g x)
  fmap g (Impure fx) = Impure (fmap g <$> fx)
#+END_SRC

** Monad instance
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Free (f (Free f a))

instance Functor f => Monad (Free f) where
  pure = Pure
  Pure x    >>= g = g x
  Impure fx >>= g = Impure ((>>= g) <$> fx)
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)
  deriving (Functor)

type Bot = Free BotF
#+END_SRC

** Lift functor
#+BEGIN_SRC haskell
liftF :: Functor f => f a -> Free f a
liftF command = Free (fmap Pure command)
#+END_SRC

** –•–µ–ª–ø–µ—Ä—ã
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)

pullUpdates :: Bot [Message]
pullUpdates = liftF (PullUpdates id)

sendMessage :: Message -> Bot ()
sendMessage msg = liftF (SendMessage msg ())

translate :: Text -> Bot (Maybe Text)
translate t = liftF (Translate t id)
#+END_SRC

** –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞
#+BEGIN_SRC haskell
proceed :: Bot ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >>= sendMessage)
  where
    translateMsg :: Message -> Bot Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)

botIO :: BotF a -> IO a
botIO (PullUpdates u) = ...
botIO (SendMessage m a) = ...
botIO (Translate t ft) = ...

type Bot = Free BotF

interpretBotIO :: Bot a -> IO a
interpretBotIO = ???
#+END_SRC

** –•–µ–ª–ø–µ—Ä—ã
#+BEGIN_SRC haskell
freeM
  :: (Functor f, Functor g)
  => (f a -> g a)
  -> Free f a
  -> Free g a
freeM phi (Pure x)    = Pure x
freeM phi (Impure fx) = Impure $ phi (freeM phi <$> fx)

monad :: Monad m => Free m a -> m a
monad (Pure x) = pure x
monad (Free mfx) = do
  fx <- mfx
  monad fx

interpret
  :: (Functor f, Monad m)
  => (f a -> m a)
  -> Free f a
  -> m a
interpret phi = monad . freeM phi
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
#+BEGIN_SRC haskell
botIO :: BotF a -> IO a

interpret
  :: (Functor f, Monad m)
  => (f a -> m a)
  -> Free f a
  -> m a

interpetBotIO :: Bot a -> IO a
interpetBotIO = interpret botIO
#+END_SRC

** –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–ª–≥–µ–±—Ä
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)

type Bot = Free BotF
#+END_SRC

** –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–ª–≥–µ–±—Ä
#+BEGIN_SRC haskell
data MessengerF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a

data TranslatorF a
  = Translate Text ((Maybe Text) -> a)
#+END_SRC

** –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–ª–≥–µ–±—Ä
#+BEGIN_SRC haskell
data MessengerF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a

data TranslatorF a
  = Translate Text ((Maybe Text) -> a)
#+END_SRC

** –¢–∏–ø —Å—É–º–º—ã
#+BEGIN_SRC haskell
data Sum f g a
  = L (f a)
  | R (g a)

instance (Functor f, Functor g) => Functor (Sum f g)
#+END_SRC

** –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–ª–≥–µ–±—Ä
#+BEGIN_SRC haskell
data MessengerF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  deriving (Functor)

data TranslatorF a
  = Translate Text ((Maybe Text) -> a)
  deriving (Functor)

type BotF = Sum MessengerF TranslatorF
#+END_SRC

** –•–µ–ª–ø–µ—Ä—ã
#+BEGIN_SRC haskell
pullUpdates :: Bot [Message]
pullUpdates = liftF $ PullUpdates id

sendMessage :: Message -> Bot ()
sendMessage msg = liftF $ SendMessage msg ()

translate :: Text -> Bot (Maybe Text)
translate t = liftF $ Translate t id
#+END_SRC

** –•–µ–ª–ø–µ—Ä—ã
#+BEGIN_SRC haskell
pullUpdates :: Bot [Message]
pullUpdates = liftF $ L $ PullUpdates id

sendMessage :: Message -> Bot ()
sendMessage msg = liftF $ L $ SendMessage msg ()

translate :: Text -> Bot (Maybe Text)
translate t = liftF $ R $ Translate t id
#+END_SRC

** –¢–∏–ø —Å—É–º–º—ã
#+BEGIN_SRC haskell
data Sum f g a
  = L (f a)
  | R (g a)
#+END_SRC

** –í–∞—Ä–∏–∞–Ω—Ç—ã —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
+ –ü–æ—Å—Ç–æ—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞ (Hierarchical Free Monads);
+ –†–∞—Å—à–∏—Ä—è–µ–º—ã–π —Å–ø–∏c–æ–∫ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ (Extensible effects);

** Hierarchical Free Monads
#+BEGIN_SRC haskell
data MessengerF next
  = PullUpdates ([Message] -> next)
  | SendMessage Message next

data TranslatorF a
  = Translate Text ((Maybe Text) -> next)
#+END_SRC

** Hierarchical Free Monads
#+BEGIN_SRC haskell
data MessengerF next
  = PullUpdates ([Message] -> next)
  | SendMessage Message next

data TranslatorF next
  = Translate Text ((Maybe Text) -> next)

data BotF a
  = EvalMessenger  (MessengerF a)
  | EvalTranslator (TranslatorF a)
#+END_SRC

** Hierarchical Free Monads
#+BEGIN_SRC haskell
data BotF a
  = EvalMessenger  (MessengerF a)
  | EvalTranslator (TranslatorF a)
  | EvalLogger     (LoggerF a)
#+END_SRC

** Hierarchical Free Monads
#+BEGIN_SRC haskell
data BotF a
  = EvalMessenger  (MessengerF a)
  | EvalTranslator (TranslatorF a)
  | EvalLogger     (LoggerF a)

botIO :: BotF a -> IO a
botIO (EvalMessenger m)  = messengerIO m
botIO (EvalTranslator m) = translatorIO m
botIO (EvalLogger m)     = evalLoggerIO m
#+END_SRC


** –ü–ª—é—Å—ã & –ú–∏–Ω—É—Å—ã

** –ü–ª—é—Å—ã:
+ –í—ã—Å–æ–∫–∞—è –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å;
+ –ß–∏—Å—Ç–æ—Ç–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏;
+ –ñ–µ—Å–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Å–ª–æ–µ–≤ (–ø—Ä–∏ HFM);

** –ú–∏–Ω—É—Å—ã:
+ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–ø—Ä–∏ initial –∫–æ–¥–∏—Ä–æ–≤–∫–µ);
+ Boilerplate;
+ –≠—Ñ—Ñ–µ–∫—Ç—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞;

** –≠—Ñ—Ñ–µ–∫—Ç—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞

** –§—É–Ω–∫—Ü–∏–∏ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
#+BEGIN_SRC haskell
map :: (a -> b) -> [a] -> [b]

filter :: (a -> Bool) -> [a] -> [a]
#+END_SRC

** –≠—Ñ—Ñ–µ–∫—Ç—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
#+BEGIN_SRC haskell
class MonadReader r m | m -> r where
  ask   :: m r
  local :: (r -> r) -> m a -> ma
#+END_SRC

** –≠—Ñ—Ñ–µ–∫—Ç—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
#+BEGIN_SRC haskell
class MonadError e m | m -> e where
  throwError :: e -> m a
  catchError :: m a -> (e -> m a) -> m a
#+END_SRC

* Freer monads
** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a
  = First a
  | Second a
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: a -> SomeType a
  Second :: a -> SomeType a
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: a -> SomeType a
  Second :: Int -> SomeType Int
#+END_SRC

** Generilized Algebraic Data Types (GADT)
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id gadt :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data SomeType a where
  First  :: b -> SomeType b
  Second :: Int -> SomeType Int
#+END_SRC

** Free monad
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Free f a
  = Pure a
  | Impure (f (Free f a))
#+END_SRC
** Free monad
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Free f a where
  Pure   :: a -> Free f a
  Impure :: f (Free f a) -> Free f a
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Lan g a where
  Lan :: g x -> (x -> a) -> Lan g a

instance Functor (Lan g) where
  fmap f (Lan gx h) = Lan gx (f . h)

lan :: g a -> Lan g a
lan ga = Lan ga id
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Lan g b where
  Lan :: (a -> b) -> g a -> Lan g b

class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers data-trim data-line-numbers='1-14|1-5|8-14'
#+BEGIN_SRC haskell
data Lan g b where
  Lan :: (a -> b) -> g a -> Lan g b

class Functor f where
  fmap :: (a -> b) -> f a -> f b


data FFree g a where
  FPure   :: a -> FFree g a
  FImpure :: g x -> (x -> FFree g a) -> FFree g a

class Monad m where
  pure  :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC

** –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä—é–∫
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
FFree g = Free (Lan f)
#+END_SRC

#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Lan g b where
  Lan :: (a -> b) -> g a -> Lan g b

class Functor f where
  fmap :: (a -> b) -> f a -> f b


data FFree g a where
  FPure   :: a -> FFree g a
  FImpure :: g x -> (x -> FFree g a) -> FFree g a

class Monad m where
  pure  :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
#+END_SRC


** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
data Bot a where
  PullUpdates :: Bot [Message]
  SendMessage :: Message -> Bot ()
  Translate   :: Text -> Bot (Maybe Text)

type BotM = FFree Bot
#+END_SRC

** Lift helper
#+ATTR_REVEAL: :data_id freer :code_attribs data-line-numbers
#+BEGIN_SRC haskell
lan :: g a -> Lan g a
lan ga = Lan ga id

send :: g a -> FFree g a
send fa = FImpure fa FPure
#+END_SRC

** –•–µ–ª–ø–µ—Ä—ã
#+BEGIN_SRC haskell
data Bot a where
  PullUpdates :: Bot [Message]
  SendMessage :: Message -> Bot ()
  Translate   :: Text -> Bot (Maybe Text)

type BotM = FFree Bot

send :: g a -> FFree g a
send fa = FImpure fa FPure

pullUpdates :: BotM [Message]
pullUpdates = send PullUpdates

sendMessage :: Message -> BotM [Message]
sendMessage = send . SendMessage

translate :: Text -> BotM (Maybe Text)
translate :: send . Translate
#+END_SRC

** –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞
#+BEGIN_SRC haskell
proceed :: Bot ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >>= sendMessage)
  where
    translateMsg :: Message -> Bot Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
#+BEGIN_SRC haskell
data Bot a where
  PullUpdates :: Bot [Message]
  SendMessage :: Message -> Bot ()
  Translate   :: Text -> Bot (Maybe Text)

botIO :: Bot a -> IO a
botIO PullUpdates       = ...
botIO (SendMessage msg) = ...
botIO (Translate t)     = ...
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
#+BEGIN_SRC haskell
data FFree g a where
  FPure   :: a -> FFree g a
  FImpure :: g x -> (x -> FFree g a) -> FFree g a

runFree
  :: Monad m
  => (f a -> m a)
  -> FFree f a
  -> m a
runFree phi m = loop m
  where
    loop (FPure x)     = pure x
    loop (FImpure u q) = phi u $ loop q
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
#+BEGIN_SRC haskell
runFree
  :: Monad m
  => (f a -> m a)
  -> FFree f a
  -> m a

botIO :: Bot a -> IO a

interpretBotIO :: FFree Bot a -> IO a
interpretBotIO = runFree botIO
#+END_SRC

** –ü–ª—é—Å—ã
** –ü–ª—é—Å—ã:
+ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å;
+ –õ–∞–∫–æ–Ω–∏—á–Ω–æ—Å—Ç—å;

** –õ–∞–∫–æ–Ω–∏—á–Ω–æ—Å—Ç—å
#+BEGIN_SRC haskell
data BotF a
  = PullUpdates ([Message] -> a)
  | SendMessage Message a
  | Translate Text ((Maybe Text) -> a)
#+END_SRC

#+BEGIN_SRC haskell
data Bot a where
  PullUpdates :: Bot [Message]
  SendMessage :: Message -> Bot ()
  Translate   :: Text -> Bot (Maybe Text)
#+END_SRC

** –õ–∞–∫–æ–Ω–∏—á–Ω–æ—Å—Ç—å
#+BEGIN_SRC haskell
pullUpdates :: Bot [Message]
pullUpdates = liftF $ PullUpdates id

sendMessage :: Message -> Bot ()
sendMessage msg = liftF $ SendMessage msg ()

translate :: Text -> Bot (Maybe Text)
translate t = liftF $ Translate t id
#+END_SRC

#+BEGIN_SRC haskell
pullUpdates :: BotM [Message]
pullUpdates = send PullUpdates

sendMessage :: Message -> BotM [Message]
sendMessage = send . SendMessage

translate :: Text -> BotM (Maybe Text)
translate :: send . Translate
#+END_SRC

* Effects systems
** Freer monad
#+BEGIN_SRC haskell
data FFree g a where
  FPure   :: a -> FFree g a
  FImpure :: g x -> (x -> FFree g a) -> FFree g a
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data Bot a where
  PullUpdates :: Bot [Message]
  SendMessage :: Message -> Bot ()
  Translate   :: Text -> Bot (Maybe Text)
#+END_SRC

** –ê–ª–≥–µ–±—Ä–∞ –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏
#+BEGIN_SRC haskell
data Messenger a where
  PullUpdates :: Messenger [Message]
  SendMessage :: Message -> Messenger ()

data Translator a where
  Translate   :: Text -> Translator (Maybe Text)
#+END_SRC

** –¢–∏–ø —Å—É–º–º—ã
#+BEGIN_SRC haskell
data Sum f g a
  = L (f a)
  | R (g a)
#+END_SRC

** –í–∞—Ä–∏–∞–Ω—Ç—ã —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
+ –ü–æ—Å—Ç–æ—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞ (Hierarchical Free Monads);
+ –†–∞—Å—à–∏—Ä—è–µ–º—ã–π —Å–ø–∏c–æ–∫ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ (Extensible effects);

** Union type
#+BEGIN_SRC haskell
data Union (sig :: [Type -> Type]) r
#+END_SRC

** Union type
#+BEGIN_SRC haskell
data Union (sig :: [Type -> Type]) r

Union '[Messenger, Translator]
#+END_SRC

** Member class
#+BEGIN_SRC haskell
data Union (sig :: [Type -> Type]) r

class Member f r where
  inj :: f a -> Union r a
  prj :: Union r a -> Maybe (f a)

decomp :: Union (f ': r) a -> Either (Union r a) (f a)
#+END_SRC

** Freer monad
#+BEGIN_SRC haskell
data FFree f a where
  FPure   :: a -> FFree f a
  FImpure :: f x -> (x -> FFree f a) -> FFree f a
#+END_SRC

** Freer monad
#+BEGIN_SRC haskell
data FFree f a where
  FPure   :: a -> FFree f a
  FImpure :: f x -> (x -> FFree f a) -> FFree f a


data FEFree r a where
  FEPure   :: a -> FEFree r a
  FEImpure :: Union r x -> (x -> FEFree f a) -> FEFree r a
#+END_SRC

** Lift helper
#+BEGIN_SRC haskell
data Union (sig :: [Type -> Type]) r

class Member f r where
  inj :: f a -> Union r a
  prj :: Union r a -> Maybe (f a)

data Eff r a where
  Pure   :: a -> Eff r a
  Impure :: Union r x -> (x -> Eff r a) -> Eff r a

send :: Member f r => f a -> Eff r a
send fa = Impure (inj fa) Pure
#+END_SRC

** –•e–ª–ø–µ—Ä—ã
#+BEGIN_SRC haskell
send :: Member f r => f a -> Eff r a
send fa = Impure (inj fa) Pure

pullUpdates
  :: Member Messager r
  => Eff r [Message]
pullUpdates = send PullUpdates

sendMessage
  :: Member Messager r
  => Message
  -> Eff r [Message]
sendMessage = send . SendMessage

translate
  :: Member Transaltor r
  => Text
  -> Eff r (Maybe Text)
translate = send . Translate
#+END_SRC

** –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞
#+BEGIN_SRC haskell
proceed :: (Member Messenger r, Member Translator r) => Eff r ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >>= sendMessage)
  where
    translateMsg :: Member Messenger r => Message -> Eff r Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å TF
#+BEGIN_SRC haskell
proceed :: (Member Messenger r, Member Translator r) => Eff r ()
#+END_SRC

#+BEGIN_SRC haskell
proceed :: (MonadMessenger m, MonadTranslator m) => m ()
#+END_SRC

** –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞
#+BEGIN_SRC haskell
proceed :: (Member Messenger r, Member Translator r) => Eff r ()
proceed = pullUpdates
  >>= traverse_ (translateMsg >=> sendMessage)
  where
    translateMsg :: Member Messenger r => Message -> Eff r Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞
#+BEGIN_SRC haskell
proceed :: (Member Messenger r, Member Translator r) => Eff r ()
proceed = do
  updates <- pullUpdates
  traverse_ (translateMsg >=> sendMessage) updates
  where
    translateMsg :: Member Messenger r => Message -> Eff r Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞
#+BEGIN_SRC haskell
proceed :: (Member Messenger r, Member Translator r) => Eff r ()
proceed = do
  updates <- pullUpdates
  runReader ctx
   $ traverse_ (translateMsg >=> sendMessage) updates
  where
    translateMsg
      :: ( Member Messenger r
         , Member (Reader ctx) r )
      => Message -> Eff r Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ë–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞
#+BEGIN_SRC haskell
proceed :: (Member Messenger r, Member Translator r) => Eff r ()
proceed = do
  updates <- pullUpdates
  runReader ctx
   $ runRandom
   $ traverse_ (translateMsg >=> sendMessage) updates
  where
    translateMsg
      :: ( Member Messenger r
         , Member Random r
         , Member (Reader ctx) r )
      => Message -> Eff r Message
    translateMsg (Msg ci t) = translate t
      <&> (maybe
             (Msg ci "Cannot translate text")
             (Msg ci))
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
#+BEGIN_SRC haskell
decomp :: Union (f ': r) a -> Either (Union r a) (f a)

interpret
  :: (eff a -> Eff effs)
  -> Eff (eff ': effs)
  -> Eff effs
interpret _   (Pure a)     = Pure a
interpret phi (Impure u f) = case decomp u of
  Right fa -> phi fa
  Left u'  -> Impure u' $ \x -> interpret phi (f x)
#+END_SRC

** –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
#+BEGIN_SRC haskell
reinterpret
  :: (f a -> Eff (g ': effs))
  -> Eff (f ': effs)
  -> Eff (g ': effs)

runM :: Monad m => Eff '[m] a -> m a

run :: Eff '[] a -> a
#+END_SRC

** Effects system libraries
+ freer-simple
+ polysemy
+ fused-effects
+ ...

** –ü–ª—é—Å—ã & –º–∏–Ω—É—Å—ã
** –ü–ª—é—Å—ã
** –ü–ª—é—Å—ã
+ –í—ã—Å–æ–∫–∞—è –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Ç—å:
  + –†–µ–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤;
  + –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –Ω–∞ –ª–µ—Ç—É;
  + –ü—Ä–æ—Å—Ç–∞—è –ø–æ–¥–º–µ–Ω–∞ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–æ–≤;
  + –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞;
+ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å;
** –ú–∏–Ω—É—Å—ã
** –ú–∏–Ω—É—Å—ã
+ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å;
+ –í—ã—Å–æ–∫–∏–π –ø–æ—Ä–æ–≥ –≤—Ö–æ–¥–∞;

* –°–ø–∞—Å–∏–±–æ –∑–∞ –≤–Ω–∏–º–∞–Ω–∏–µ!
* Questions?

* Appendix

* Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
** Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
 *Type class* ‚âà *Interface*

** Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
 *Type class* ‚âà *Interface*

#+ATTR_REVEAL: :data_id type-class :code_attribs data-trim data-line-numbers='1-3|1|2|3'
#+BEGIN_SRC haskell
data Bool
  = True
  | False
#+END_SRC

** Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
 *Type class* ‚âà *Interface*

#+ATTR_REVEAL: :data_id type-class :code_attribs data-trim data-line-numbers='1-6|5-6|5|6'
#+BEGIN_SRC haskell
data Bool
  = True
  | False

class Show a where
  show :: a -> String
#+END_SRC

** Type class
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
 *Type class* ‚âà *Interface*

#+ATTR_REVEAL: :data_id type-class :code_attribs data-trim data-line-numbers='1-10|8-10|8|9-10'
#+BEGIN_SRC haskell
data Bool
  = True
  | False

class Show a where
  show :: a -> String

instance Show Bool where
  show True  = "True"
  show False = "False"
#+END_SRC

** –§—É–Ω–∫—Ü–∏–∏ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
#+ATTR_REVEAL: :data_id tf
#+BEGIN_SRC haskell
map :: (a -> b) -> [a] -> [b]
#+END_SRC

** –¢–∏–ø—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id type-class2 :code_attribs
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** –¢–∏–ø—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :data_id type-class2 :code_attribs data-line-numbers='1-2|1'
#+BEGIN_SRC haskell
class Functor (f :: Type -> Type) where
  fmap :: (a -> b) -> f a -> f b
#+END_SRC

** –¢–∏–ø—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:
#+ATTR_REVEAL: :data_id type-class2 :code_attribs data-line-numbers='1-6|4-6'
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b

instance Functor Maybe where
  fmap f (Just a) = Just $ f a
  fmap _ Nothing  = Nothing
#+END_SRC
